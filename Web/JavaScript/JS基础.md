# JS认知
## JS组成
1. ECMAScript，JS语法
2. DOM，页面文档对象模型
3. BOM，浏览器对象模型

## JS书写位置
1. 行内式  
    + 将单行或少量代买写在HTML标签的事件属性中（以on开头的属性）  
    + HTML中推荐使用双引号，JS中推荐使用单引号
2. 内嵌式
`<script></script>`
3. 外部式
`<script scr="my.js"></script>`

## JS注释
1. 单行注释//（ctrl + /）
2. 多行注释/*    */（shift + alt + a）



# 输入输出语句
## alert
1. 弹出警示框
2. 语法
`prompt('弹出的语句');`

## console
1. 控制台输出，用于测试
2. 语法
`console.log('输出的语句');`

## dir
1. 语法`console.dir(元素对象);`
2. 打印DOM返回的元素对象

## prompt
1. 弹出输入框
2. 语法
`prompt('请用户输入的提示语句');`
3. 输入进来的值是字符串类型




# 变量
变量用于存放数据，是内存中申请的一段空间

## 变量的使用
### 变量声明
1. `var 变量名;`
2. var是JS关键字，用于声明变量。使用后计算机自动为变量分配内存空间，不需要程序员管
### 变量赋值
1. `变量名 = 值;`
### 变量初始化
1. `var 变量名 = 值;`
### 同时声明
```JavaScript
var 变量名1 = 值,
    变量2 = 值;
```
### 可以不声明直接使用
1. 但是会变成全局变量

## 变量命名规范
1. 由字母、数字、下划线、美元符号
2. 严格区分大小写
3. 不能以数字开头
4. 不能是关键字和保留字

## 检测数据类型
`typeof 待检测变量`



# 数字型Number
数字类型可以用来保存整数值，也可以保存浮点数

## 整型

## 浮点型

## 数字型进制
1. 八进制：数字前+0
2. 16进制：数字前+0x

## 数字范围
1. 最大值1.79e+308
2. 最小值5e-324

## 特殊值
1. 无穷大：Infinity
2. 无穷小：-Infinity
3. 非数字：NaN

## 数字判断
1. `isNaN()`判断是不是非数字

## 其他类型转换成数字型
1. `parseInt(字符串型变量)`变为整型
    + 会去除数字之后的其他字符串
    + 但是不能去除数字之前的字符串
2. `parseFloat(字符串型变量)`变为浮点型
    + 会去除数字之后的其他字符串
    + 但是不能去除数字之前的字符串
3. `Number(变量)`
4. 利用算术运算隐式转换为数字型



# 字符串型String
推荐使用单引号

## 字符串嵌套
1. 外单内双进行嵌套

## 字符串转义符
1. 换行`\n`
2. tab缩进`\t`
3. 空格`\b`

## 字符串的拼接
1. 用+拼接
2. 只要有一个部分是字符串，输出都是字符串，和其他数据类型没关系
3. 变量可以直接把内容拼接到字符串里

## 字符串常用方法
[字符串常用方法](https://www.runoob.com/jsref/jsref-obj-string.html)
1. 返回长度`字符串名.length`
2. 返回指定位置字符串内容`字符串名.charAt(位置索引)`
3. 返回指定字符在字符串中首次出现的位置`字符串名.indexOf(查找的字符,起始的位置)`
4. 判断子字符串的存在`字符串.includes(子字符串)`
5. 大小写转换`字符串名.toLowerCase()|字符串名.toUpperCase()`

## 其他类型转换成字符串
1. `变量.toString()`
2. `String(变量)`函数强制转换
3. 加号拼接

## 字符串的不可变
1. 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间
2. 因为字符串的不可变不要大量拼接字符串



# 布尔型Boolean

1. true可以当1来看
2. false可以当0来看

## 其他类型转换成布尔型
1. `Boolean(变量)`
2. 代表空的''|0|NaN|null|undefined转换成false
3. 其他都是true



# 运算符
运算符（operator）也称为操作符，用于实现赋值、比较和执行算术运算等功能的符号

## 算数运算符
![算数运算符汇总.jpg](https://i.loli.net/2020/12/16/jHzUZP3Vwav6iLk.jpg)
1. 浮点数存在阶段误差，不要判断浮点数是否相等
2. 算数运算符的优先级和平时一样

## 递增递减运算符
1. `++`递增，每次加1
2. `--`递减，每次减1
3. 前置递增|递减：运算符在变量前面，先计算后输出
4. 后置递增|递减：运算符在变量后面，先输出后计算
```JavaScript
var age = 10
console.log(++age + 10); //输出21，前置递增
age = 10
console.log(age++ + 10); //输出20，后置递增
// 但是两个age都是11
```

## 比较运算符
![比较运算符汇总.jpg](https://i.loli.net/2020/12/16/ZxR1udmONy3jor5.jpg)
1. `==`比较的时候会自动转换数据类型
2. `===`同时要求值和数据类型
```JavaScript
console.log(18 == '18'); //true
console.log(18 === '18'); //false
```

## 逻辑运算符
![逻辑运算符汇总.jpg](https://i.loli.net/2020/12/16/cSAE8t6PZHRnlYy.jpg)
1. 短路运算：当有多个表达式时，左边表达式可以确定结果时就不再进行有右边的运算
### &&断路
1. `表达式1 && 表达式2`
2. 表达式1真，返回表达式2
3. 表达式1假，返回表达式1
### ||断路
1. `表达式1 || 表达式2`
2. 表达式1真，返回表达式1
3. 表达式1假，返回表达式2

## 赋值运算符
![赋值运算符汇总.jpg](https://i.loli.net/2020/12/16/hXMkOCN9quIDUjG.jpg)

## 运算符优先级
![运算符优先级.jpg](https://i.loli.net/2020/12/16/IFoSA4dx8q5BlJ2.jpg)



# 流程控制

## 顺序流程控制
直接写就好

## 分支流程控制
### if
1. 语法结构
```JavaScript
if (条件表达式) {
    条件成立时的执行语句
}
```
### if-else双分支
1. 语法结构
```JavaScript
if (条件表达式) {
    条件成立时的执行语句
} else{
    条件不成立时的执行语句
}
```
2. if和else里只有一个语句能执行
### 多分支语句
1. 语法结构
```JavaScript
if (条件表达式1) {
    条件1成立时的执行语句
} else if (条件表达式2){
    条件1不成立条件3成立时的执行语句
} else{
    所有条件都不成立时的执行语句
}
```
### 三元表达式
1. 语法结构`条件表达式 ? 表达式1 : 表达式2`
2. 执行思路
    + 条件表达式真，返回表达式1
    + 条件表达式假，返回表达式2
### switch
1. 语法结构
```JavaScript
switch (表达式) {
    case value1:
        表达式与value1匹配时的执行语句;
        break;
    case value2:
        表达式与value2匹配时的执行语句;
        break;
    default:
        都不满足时的执行语句;
}
```
2. 匹配的要求是值和数据类型都相等才算匹配
3. 要写break，否则switch会认为一直是匹配上的直接执行后续case的执行语句

## 循环流程控制
### for循环
1. 语法结构
```JavaScript
for (初始化变量;条件表达式；操作表达式) {
    循环体
}
```
### while循环
1. 语法结构
```JavaScript
while (条件表达式) {
    循环体
}
```
### do-while循环
1. 语法结构
```JavaScript
do {
    循环体
} while (条件表达式)
```
2. 限制性循环体再判断条件
### continue
1. 立即跳出本次循环，继续下一次循环
### break
1. 立即跳出整个循环



# 数组Array

## 创建数组
### new关键字创建数组
1. `var 数组名 = new Array();`
2. 通过实例化Array构造对象创建的
3. `var 数组名 = new Array(n);`创建长度为n的空数组
4. `var 数组名 = new Array(x,y);`创建[ x,y]数组
### 利用数组字面量创建数组
1. 数组字面量[]
2. 语法`var 数组名 = [];`
3. 数组里的数据用逗号分隔
4. 数组里的数据称为数组元素

## 数组索引
1. 索引（下标）：用来访问数组元素的序列，从0开始
2. 通过索引号访问数组元素`数组名[索引号]`
3. 没有数组元素，访问结果为undefined

## 数组长度
`数组名.length`

## 数组新增元素
### 修改length长度
`数组名.length = 5`添加空元素
### 增加索引号
`数组名[索引号] = 新加元素`追加元素

## 检测是否为数组
### instanceof 运算符
1. 语法`待检测内容 instanceof Array`
### .isArray()
1. 语法`Array.isArray(待检测内容)`
2. ie9以上版本才支持

## 添加数组元素
### .push()
1. 在尾部添加一个或多个数组元素
2. 语法`数组.push(添加的元素)`
3. push完后返回的是新数组的长度
4. 原数组也会发生变化
### .unshift()
1. 在开头添加一个或多个数组元素
2. 语法`数组.unshift(添加的元素)`
3. unshift完后返回的是新数组的长度
4. 原数组也会发生变化

## 删除数组元素
### .pop()
1. 删除数组最后的一个元素，一次只能删除一个元素
2. 语法`数组.pop()`
3. pop完后返回被删除的元素
4. 原数组也会发生变化
### .shift()
1. 删除数组第一个的一个元素，一次只能删除一个元素
2. 语法`数组.shift()`
3. shift完后返回被删除的元素
4. 原数组也会发生变化

## 数组排序
### .reverse()
1. 翻转数组
2. 语法`数组.reverse()`

### .sort()
1. 冒泡排序
2. 语法`数组.sort()`
3. 这样排序是先看按照最高位排序，再按后面的位数排序，个位数可以用
4. 
```JavaScript
数组.sort(function(a,b){
    // 按照升序排序
    return a-b;
    // 按照降序排序
    return b-a;
});
```

## 数组索引
### .indexOf()
1. 查找数组中给定元素的第一个索引
2. 不存在返回-1
3. 语法`数组名.indexOf(元素名,查找起始位置)`
### .lastIndexOf()
1. 查找数组中给定元素的最后一个索引
2. 不存在返回-1
3. 语法``数组名.lastIndexOf(元素名)`

## 数组转换成字符串
### toString()
1. 把数组转换成字符串，逗号分隔每一项
### join('分隔符')
1. 把数组中的所有元素转换为一个字符串
2. 分隔符默认为逗号

## 数组切割
### .concat()
1. 连接两个或多个数组
2. 返回新数组
3. 不影响原数组
### .slice()
1. 截取数组
2. 返回新数组
3. 语法`数组名.slice(开始缩印,结束索引)`
### .splice()
1. 删除数组内元素
2. 返回被删除的新数组
3. 会影响原数组



# 函数
1. 函数：封装了可被调用实行的代码块

## 函数的使用
### 声明函数
#### 利用函数关键字声明（命名函数）
1. 语法`function 函数名(形参){}`
2. function是声明函数的关键字
3. 函数名一般是动词
#### 函数表达式声明（匿名函数）
1. 语法`var 变量名 = function(形参){}`
### 调用函数
1. 语法`函数名();`

## 函数的参数
### 形参
1. 函数声明的是形参
2. 语法`function 函数名(形参1,形参2):{}`
3. 是一种不用声明的变量
4. 形参不赋值时默认为undefined
### 实参
1. 调用函数的是实参
2. 语法`函数名(实参1,实参2);`
### 实参形参的关系
1. 形参接受实参的数值
2. 形参和实参可以不匹配
3. 实参个数多于形参个数，后面的实参直接抛弃

## 函数返回
1. 语法`return 需要返回的结果;`
2. return具有终止函数的功能
3. return只能返回一个值，如果多个值返回最后一个值
4. 函数如果没有return，则返回undefined

## arguments
1. arguments是当前函数的内置对象，存储了传递的所有实参
2. 语法
```JavaScript
function 函数名():{
    console.log(arguments)
    }
```
3. arguments展示形参为一个伪数组
    + 可以遍历
    + 具有length属性
    + 按索引方式储存数据
    + 不具有数组的push、pop等方法
4. 只有函数有arguments对象



# 作用域

## 作用域概述
1. 作用域：限定代码中用到的名字可用性的代码范围
2. 作用域的目的是提高程序的可靠性，减少命名冲突
3. 作用域分为全局作用域和局部作用域
4. 全局作用域：整个scrip标签或者一个单独的js文件
5. 局部作用域：只在函数内部，也可以叫做函数作用域
6. 不同作用域下命名不冲突

## 变量的作用域
### 全局变量
1. 在全局作用域下的变量
2. 除了全局状态下声明变量还有在函数内部不声明直接赋值的变量也是全局变量
### 局部变量
1. 在局部作用域下的变量
2. 只能在函数内部使用
3. 函数的形参也可以看作局部变量
### 全局效率
1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源
2. 局部变量程序执行完毕就会销毁，比较节约内容资源

## 块级作用域
1. 目前js没有块级作用域
2. 在es6时新增了块级作用域
3. 块级作用域：用{}包含的

## 作用域链
1. 内部函数访问外部函数的变量采取的是链式查找的方式来决定是哪个值
2. 作用域链：这种链式查找方式结构
3. 就近原则



# 预解析

## JS代码运行
1. 预解析：js引擎会把里面所有的var还有function提升到当前作用域的最前面
2. 代码执行：按照代码书写的顺序从上往下执行

## 变量预解析
1. 变量预解析又叫变量提升
2. 只提升变量声明不提升赋值操作
## 函数预解析
1. 函数预解析又叫函数提升
2. 只提升函数声明不调用
3. 函数预解析只适用于用函数关键字声明的情况



# 对象
1. 对象是一组无需的相关属性和方法的集合
2. 属性：事物的特征
3. 方法：事物的行为

## 创建对象
### 利用字面量创建对象
1. 对象字面量为{}
```JavaScript
var obj = {
    //属性
    uname = 'qww', 
    //方法
    sayHi : function(){
        console.log('hi');
    }
}
```
2. 里面的属性或者方法采取键值对的形式
3. 多个属性或者方法中间用逗号隔开
4. 方法后面跟的是一个匿名函数
### 利用new Object创建对象
```JavaScript
var obj = new Object();
obj.uname = 'qww';
obj.sayHi = function(){
    console.log('hi');
}
```
1. 利用等号赋值的方法添加对象的属性和方法
2. 每个属性和方法之间用分号结束
### 利用构造函数创建对象
1. 构造函数：把对象里相同的属性和方法抽象出来封装到函数里面
2. 语法规范
```JavaScript
function 构造函数名() {
    this.属性 = 值;
    this.方法 = function(){}
}
new 构造函数名();
```
3. 构造函数名字首字母大写
4. 构造函数不需要return就可以返回结果
5. 调用构造函数必须使用new
6. 属性和方法前面必须添加this
7. 对象是一个具体的事物，特指某一个；构造函数是一个大类，类似于其他语言的类
8. 利用构造函数创建对象的过程也叫对象的实例化

## 使用对象
### 调用对象属性
1. `对象名.属性名`
2. `对象名['属性名']`
### 调用对象方法
1. `对象名.方法名()`
2. 不能忘记添加小括号

## new关键字
1. new构造函数可以在内存中创建了一个空的对象
2. this指向刚才创建的空对象
3. 执行构造函数里面的代码，给空对象添加属性和方法
4. 返回这个对象（所以构造函数不需要return）

## 遍历对象
1. for in语句可以对数组或者对象的属性进行循环操作
2. 语法
```JavaScript
for (var k in obj) {
    console.log(k); //输出的是属性名
    console.log(obj[k]); //输出的属性值
}
```



# 内置对象
1. JS中对象分成3种：自定义对象、内置对象、浏览器对象
2. 内置对象：JS语言自带的一些对象，供开发者使用，并提供了一些常用的或是最基本的必要功能（属性和方法）

## Math内置对象
1. Math不是一个函数对象，不是一个构造器，不需要New来调用，而是直接使用
### Math常用属性和方法
1. `Math.PI`圆周率
2. `Math.floor()`向下取整
3. `Math.ceil()`向上取整
4. `Math.round()`四舍五入，就近取整，-3.5取-3
5. `Math.abs()`绝对值，可以隐式转换，会把字符串转换成数字型
6. `Math.max/min()`最大、最小值
7. `Math.random()`0~1的随机数

## 日期内置对象
1. Date实例用来处理日期和时间
2. Date是一个构造函数，必须使用New调用
### 使用Date
1. 语法`var date = new Date();`
2. 如果没有参数返回系统的当前时间
### 参数常用写法
1. 数字型`2021,03,09`月份会多1，因为从0开始记录
2. 字符串型`'2021-03-09 16:58:10'` 常用
### 日期格式化
![日期格式化方法.jpg](https://i.loli.net/2021/03/09/9SXKFgviL7lpceA.jpg)
1. 月份返回的会小1个月
2. 返回星期的时候，周日返回的是0
### 获取时间戳
1. 时间戳是距离1970年1月1日的总毫秒数
2. `Date.valueOf()`
3. `Date.getTime()`
4. 可简化为`var date1 = +new Date();`，最常用的写法
5. H5新增的方法`Date.now()`

# 基本包装类型
1. 基本包装类型就是把简单数据类型包装成为了复杂数据类型，使得简单数据类型有了属性和方法
2. 过程：
    + 把简单数据类型包装为复杂数据类型
    + 把临时变量的值给str
    + 销毁临时变量
3. 为了方便操作基本数据类型，JavaScript提供了三个特殊的引用类型：String、Number和Boolean

# 数据类型

## 堆和栈
其实JavaScript中没有堆和栈的概念，但可以方便理解代码的执行方式
### 栈（操作系统）
1. 由操作系统自动分配释放存放函数的参数值、局部变量的值等
2. 其操作方式类似于数据结构中的栈
3. 简单数据类型存放在栈里面
### 堆（操作系统）
1. 存储复杂类型（对象）
2. 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收

## 简单数据类型
1. 简单数据类型又叫作基本数据类型或者值类型
2. 值类型：在存储时变量中存储的是值本身
3. string、number、boolean、undefined、null
4. 简单数据类型null返回的是一个空对象
### 简单数据类型内存分配
1. 简单数据类型存放在栈里面，里面直接开辟一个空间存放的是值

## 复杂数据类型
1. 复杂数据类型又叫引用类型
2. 通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等
### 复杂数据类型内存分配
1. 复杂数据类型首先在栈里存放地址，16进制
2. 然后栈中的地址指向堆里的数据



# 面向对象

## 面向对象编程介绍
1. 面向过程，POP(Process-oriented programming)。
   + 分析出解决问题所需的步骤，然后用函数把步骤一步步实现，使用的时候再一个个依次调用
   + 分析好步骤，按照步骤解决问题
2. 面向对象，OOP(Object Oriented Programming)
   + 把事务分解成为一个个对象，然后由对象之间分工与合作
   + 以对象功能划分问题，而不是步骤
   + 特点：
        - 封装性
        - 继承性
        - 多态性
3. 两者对比
    + 面向过程
        - 优点：性能比面向对象高，适合跟硬件联系很紧密的东西
        - 缺点没：有面向对象易维护、易复用、易扩展
    + 面向对象
        - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，是系统更佳灵活
        - 缺点：性能比面向过程低

## ES6中的类和对象
### 面向对象的思维特点
1. 抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板）
2. 对类进行实例化，获取类的对象
### 对象
1. 对象是一个具体的事物
2. 在JavaScript中，对象是一组无需的相关属性和方法的集合，所有的事物都是对象
3. 对象由属性和方法组成
   + 属性：事物的特征，在对象中用属性来表示
   + 方法：事物的行为，在对象中用方法来表示
### 类class
1. ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象
2. 类抽象了对象的公共部分，泛指某一大类
3. 对象特指某一个，通过类实例化一个具体的对象
### 创建类
1. 语法`class 类名{类内容}`
2. 类名习惯首字母大写
3. 创建实例`var 对象名 = new 类名();`
4. 类必须使用new实例化对象
### 类constructor构造函数
1. constructor()方法是类的构造函数，用于传递参数，返回实例对象
2. 通过new命令生成对象实例，自动调用该方法
3. 如果没有显示定义，类内部会自动给我们创建一个constructor()
4. 语法
```JavaScript
class 类名 {
    construction(形参){
        实参赋值
    }
}
```
5. 构造函数不需要加function