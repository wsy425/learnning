# 概述

## 操作系统的概念
### 操作系统的定义
1. 负责管理协调硬件、软件等计算机资源的工作
2. 为上层的应用程序、用户提供简单易用的服务
3. 操作系统是系统软件而不是硬件
### 操作系统的功能和目标
1. 作为系统资源的管理者
功能：处理机管理；存储器管理；文件管理；设备管理
目标：安全、高效
2. 作为用户和计算机硬件的接口
功能：命令借口；程序接口；GUI
目标：方便用户使用
3. 作为最接近硬件的层次
实现对硬件机器的扩展

## 操作系统的特征
### 并发
指两个或多个时间在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的
操作系统的并发性：计算机系统中同时存在着多个运行着的程序
### 共享
资源共享：系统中的资源可供内存中多个并发执行的进程共同使用
1. 互斥共享方式
2. 同时共享方式
### 虚拟
把一个物理上的实体变为若干个逻辑上的对应物
空分复用技术；时分复用技术
### 异步
在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的而是走走停停，以不可预知的速度向前推进
只有系统拥有并发性才会导致异步性

## 操作系统的发展和分类
### 手工操作阶段
用户独占全集、人机速度锚段导致资源利用率极低
### 单道批处理系统
引入脱机输入/输出（用磁带完成），并监督程序负责控制作业的输入、输出
缓解了人机速度矛盾，内存仅有一道程序运行
### 多道批处理系统
多道程序并发执行，共享计算机资源
没有人机交互功能，用户响应时间长
### 分时操作系统
计算机以时间片为单位轮流为各个用户/作业服务，各个用户通过终端与计算机进行交互
不能优先处理一些紧急任务
### 实时操作系统
能够优先响应一些紧急任务，具有及时性和可靠性
1. 硬实时系统：必须在绝对严格的规定时间内完成处理
2. 软实时操作系统：能接受偶尔违反时间规定

## 操作系统的运行机制和体系结构
指令：处理器能识别、执行的最基本命令
### 运行机制
#### 两种指令
1. 特权指令：不允许用户程序使用
2. 非特权指令：
#### 两种处理器状态
1. 用户态（目态）：只能执行非特权指令
2. 核心态（管态）：特权和非特权指令都可以执行
#### 两种程
1. 内核程序：操作系统的内核程序书系统的管理者
   + 既可以执行特权指令也可以执行非特权指令
   + 运行在核心态
2. 应用程序
   + 只能执行非特权指令
   + 运行在用户态
### 操作系统内核
1. 内核是计算机上配置的底层程序，是操作系统最基本、最核心的部分
2. 时钟管理：实现计时功能
3. 中断处理：负责实现中断机制
4. 原语
   + 一种特殊的程序
   + 处于操作系统最底层，最接近硬件的部分
   + 运行具有原子性，只能一气呵成不能被中断
   + 运行时间较短、调用频繁
5. 对系统资源进行管理的功能
   + 进程管理
   + 存储器管理
   + 设备管理
### 操作系统体系结构
1. 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态
   + 优点：高性能
   + 缺点：内核代码庞大，结构混乱，难以维护
2. 微内核：只把最基本的功能保留在内核
   + 优点：内核功能少，结构清晰，方便维护
   + 缺点：需要频繁地在核心态和用户态之间切换，性能低

## 中断和异常
1. 发生中断就一位置需要操作系统介入，开展管理工作
2. 中断发生时CPU立即进入核心态，使操作系统获得计算机的控制权
3. 中断使用户态到核心态切换的唯一途径
### 内中断
1. 也成异常、例外、陷入
2. 信号的来源：CPU内部，与当前执行的指令有关
#### 分类1
1. 自愿中断，又称指令中断
2. 强迫中断：
   + 硬件故障
   + 软件中断
#### 分类2
1. 陷阱、陷入（trap）：有意而为之的异常
2. 故障（fault）：由错误条件引起的
3. 终止（abort）：不可恢复的致命操作造成的结果
### 外中断
1. 简称中断
2. 信号的来源：CPU外部与当前执行的指令无关
#### 外设请求
#### 人工干预
#### 处理过程
1. 执行完每个指令之后，CPU都要检测当前是否有外部中断信号
2. 如果检测到外部中断信号，则需要保护被中断进程的CPU环境
3. 根据中断信号类型转入响应的中断处理程序
4. 恢复原进程的CPU环境并推出中断，返回原进程继续往下执行

## 系统调用
1. 系统调用是操作系统提供给应用程序使用的接口
2. 应用程序通过系统调用请求操作系统的服务可以保证系统的稳定性和安全性
3. 系统调用的相关处理在核心态进行
### 系统调用过程
1. 传递系统调用参数
2. 执行陷入指令
3. 执行系统调用响应服务程序
4. 返回用户程序
5. 发生系统调用请求实在用户态，但对系统调用的相应处理在核心态下进行
6. 陷入指令是唯一一个只能在用户态执行，而不能在核心态执行的指令



# 进程
## 进程概述
### 进程的定义
1. 程序：一个指令序列
2. 进程实体（进程映像）
   + 进程控制块（PCB）：系统为每个运行的程序配置的一个数据结构，用来描述进程的各种信息
   + 程序段
   + 数据段
3. PCB是进程存在的唯一标志
4. 创建进程实质上是创建进程实体中的PCB；撤销进程实质上是撤销进程实体中的PCB
5. 进程定义：强调动态性
   + 进程是程序的一次执行过程
   + 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
   + 进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位
   + 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
### 进程的组成
1. 进程（进程实体）由程序段、数据段、PCB三个部分组成
2. 程序段：存放要执行的代码
3. 数据段：存放程序运行时使用、产生的运算数据
4. PCB：包含操作系统对其进行管理所需的各种信息
   + 进程描述信息
        - 进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程
        - 用户标识符UID
   + 进程控制和管理信息
        - 进程当前状态
        - 进程优先级
   + 资源分配清单
        - 程序段指针
        - 数据段指针
        - 键盘
        - 鼠标
   + 处理机相关信息：各种寄存器值
### 进程的组织
1. 进程的组成讨论的是一个进程内部由那些部分构成的问题；而进程的组织讨论的是多个进程之间的组织方式问题
2. 链接方式
   + 按照进程状态将PCB分为多个队列
   + 操作系统持有指向各个队列的指针
3. 索引方式
   + 根据进程状态的不同，建立几张索引表
   + 操作系统持有指向各个索引表的指针
### 进程的特征
1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的
2. 并发性：内存中有多个进程实体，各进程可并发执行
3. 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
4. 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题
5. 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

## 进程状态
### 进程的状态
1. 运行态：战友CPU，并在CPU上运行
   + 在单核处理机环境下，每一个时刻最多只有一个进程处于运行态
2. 就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
   + 进程已经拥有了除处理机之外的所有需要资源，一旦你获得处理机可以立即进入运行态开始运行
3. 阻塞态（等待态）：因等待某一事件而暂时不能运行
4. 创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB
5. 终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB
### 进程状态的装换
1. 就绪态———运行态：进程被调度
2. 运行态———就绪态：时间片到，或CPU被其他搞优先级的进程抢占
3. 运行态———阻塞态：等待系统资源分配，或等待某时间发生（主动行为）
4. 阻塞态———就绪态：资源分配到位，等待的时间发生（被动行为）
5. 创建态———就绪态：系统完成创建进程相关工作
6. 运行态———终止态：进程运行结束，或运行过程中遇到不可修复的错误

## 进程控制
1. 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新锦成、撤销已有进程、实现进程状态转换等功能
2. 用原语实现进程控制
3. 原语的特点是执行期间不允许中断，只能一气呵成
4. 这种不可被中断的操作称为原子操作，采用“关中断指令”和“开中断指令”实现
5. 原语运行在核心态
6. 关/开中断指令只允许在核心态下执行
### 进程的创建
1. 创建原语
   + 申请空白PCB
   + 为新进程分配所需资源
   + 初始化PCB
   + 将PCB插入就绪队列
2. 引起进程创建的时间
   + 用户登录：分时系统中，用户登录成功，系统会建立一个新的进程
   + 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
   + 提供服务：用户向操作系统提出某些请求时
   + 应用请求：由用户进程主动请求创建一个子进程
### 进程的终止
1. 撤销原语
   + 从PCB集合中找到终止进程的PCB
   + 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
   + 终止其所有紫禁城
   + 将该进程拥有的所有资源归还给父进程或操作系统
   + 删除PCB
2. 引起进程终止的事件
   + 正常结束
   + 异常结束
   + 外界干预
### 进程的阻塞
1. 阻塞原语
   + 找到要阻塞的进程对应的PCB
   + 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
   + 将PCB插入响应时间的等待队列
2. 引起进程阻塞的事件
   + 需要等待系统分配某种资源
   + 需要等待相互合作的其他进程完成工作
### 进程的阻塞
1. 唤醒原语
   + 在事件等待队列中找到PCB
   + 将PCB从等待队列移除，设置进程为就绪态
   + 将PCB插入就绪队列，等待被调度
2. 引起进程唤醒的事件
   + 等待事件的发生
### 进程的切换
1. 切换原语
   + 将运行环境信息存入PCB
   + PCB移入相应队列
   + 选择另一个进程执行，并更新其PCB
   + 根据PCB恢复新进程所需的运行环境
2. 引起进程切换的事件
   + 当前进程时间片到
   + 由更高优先级的进程到达
   + 当前进程主动阻塞
   + 当前进程终止

## 进程通信
1. 进程通信指的进程之间的信息交换
2. 进程是分配系统资源的单位，因此各进程用欧的内存地址空间相互独立
3. 一个进程不能直接访问另一个进程的地址空间
### 共享存储
1. 两个进程对共享空间的访问必须是互斥的
2. 给予数据结构的共享：速度慢、限制多，低级通信方式
3. 给予存储区的共享：速度快、限制少，高级通信方式
### 管道通信
1. 管道：用于连接读写进程的共享文件，其实就是在内存中开辟一个大小固定的缓冲区
2. 管道只能采用半双工通信。要实现双向同事通信，需要设置两个管道
3. 各进程要互斥地访问管道
4. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用江北阻塞，等待读进程将数据取走；当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞
5. 数据一旦被读出，就从管道中被抛弃。读进程最多只有一个
### 消息传递
1. 进程间的数据交换以格式化消息为单位。通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换
2. 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
3. 间接通信方式：消息先发送到中间实体

## 线程
1. 线程：基本的CPU执行单元，也是程序执行流的最小单位
2. 引入线程之后，不仅进程之间可以并发，进程内个线程之间也可以并发。提高了系统的并发度
3. 引入线程后，进程只作为除CPU之外的系统资源的分配单元
### 线程作用
1. 资源分配、调度
   + 传统进程机制中，进程是资源分配、调度的基本单位
   + 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
2. 并发性
   + 传统进程机制中，只能进程间并发
   + 引入线程后，各线程间也能并发，提升了并发度
3. 系统开销
   + 传统的进程并发，需要切换进程的运行环境，系统开销很大
   + 线程间并发，如果是统一进程内的线程切换，则不需要切换进程环境，系统开销小
   + 引入线程后，并发所带来的的系统开销减小
### 线程属性
1. 线程是处理机调度的单位
2. 多CPU计算机中，各个线程克占用不同的CPU
3. 每个线程都有一个线程ID、线程控制块（TCB）
4. 线程也有就绪、足额、运行三种基本状态
5. 线程几乎不拥有系统资源
6. 统一进程的不同线程间共享进程的资源
7. 由于共享内存地址空间，统一进程中的线程建通信甚至无需系统干预
8. 统一进程中的线程切换，不会引入进程切换
9. 不同进程中的线程切换，会引入进程切换
10. 切换同进程内的线程，系统开销很小
11. 切换进程，系统开销很大
### 线程的实现方式
#### 用户级线程（ULT）
1. 用户级线程由应用程序通过线程库实现
2. 所有线程管理工作都由应用程序负责（包括线程切换）
3. 用户级线程中，线程切换可以在用户态下完成，无需操作系统干预
#### 内核级线程（KLT）
1. 内核级线程的管理工作由操作系统内核完成
2. 内核级线程的切换必须在核心态下才能完成
3. 内核级线程才是处理机分配的单位
### 多线程模型
1. 多对一模型：多个用户级线程映射到一个内核级线程
   + 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
   + 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发性不高。多个线程不可在多核处理机上并行运行
2. 一对一模型：一个用户级线程映射到一个内核级线程
   + 优点：当一个用户级线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
   + 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态。线程管理的成本高，开销大
3. 多对多模型：n用户线程映射到m各内核级线程（n>=m）
   + 集二者所长
