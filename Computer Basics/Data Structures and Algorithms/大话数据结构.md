# 数据结构绪论
## 基本概念和数据
### 数据
描述客观事物的符号；计算机可操作对象，能被计算机识别并输入给计算机处理
### 数据元素
组成数据的、有一定意义的基本单位，在计算机中作为整体处理
### 数据项
数据项是数据不可分割的最小单位
一个数据元素可以由若干个数据项组成
### 数据对象
性质相同的数据元素的集合，是数据的子集
### 数据结构
相互之间存在一种或多种特定关系的数据元素集合
## 逻辑结构与物理结构
数据结构分为逻辑结构和物理结构
### 逻辑结构（面向问题）
数据对象中数据元素之间的相互关系
1. 集合结构：数据元素处理同属于一个集合外，之间没有其他关系
2. 线性结构：数据元素之间是一对一关系
3. 树形结构：数据元素之间存在一种一对多的层次关系
4. 图形结构：数据元素是多对多的关系
### 物理结构（面向计算机）
数据的逻辑结构在计算机中的存储形式
1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致
2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据存储关系不能反映逻辑关系，需要用执政存放数据元素地址
## 抽象数据类型
### 数据类型
数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称
### 抽象数据类型
抽象数据类型（ADT）：是指一个数学模型及定义在该模型上的一组操作


# 算法（Algorithm）
与MOOC绪论联系
## 算法定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
## 算法的特性
### 输入输出
算法具有零个或多个输入，至少有一个输出
### 有穷性
算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成
### 确定性
算法的每一步骤都具有确定的含义
### 可行性
算法每一步都必须是可行的，每一步都能通过执行有限次数完成
## 算法设计要求
### 正确性
算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
分成四个层次：
1. 没有语法错误
2. 对于合法的输入数据能够产生满足要求的输出结
3. 对于非法的输入数据能够得出满足规格说明的结果。
4. 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
### 可读性
算法设计的另一目的是为了便于阅读、理解和交流
### 健壮性
当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
### 时间效率高、存储量低
设计算法应该尽量满足时间效率高和存储量低的需求
## 算法效率的度量方法
### 事后统计方法
主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
缺陷多
### 事前分析估计方法
计算机程序编制前，依据统计方法对算法进行估算
在分析程序的运行时间时，最重要的是把程序看成是强立于程序设计语言的算法或一系列步骤
## 函数的渐进增长
函数的渐近增长:给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n> N, f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快子g（n）
通过函数的渐进增长得出结论：
判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数
## 算法时间复杂度（）
### 算法时间复杂度定义
T（n）=O（f（n）），大O记法
O（1）：常数阶
O（n）：线性阶
O（n^2）：平方阶
### 大O阶方法
1. 忽略常数项
2. 忽略低阶项
3. 忽略常系数
### 常见时间复杂度
![QQ截图20200918205835.jpg](https://i.loli.net/2020/09/18/bPImFSq29ltLzWh.jpg)
### 最坏情况与平均情况
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时闯是所有情况中最有意义的，因为它是期望的运行时间。
## 算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(o)= O(f(o))，其中，0为问题的规模，f(n)为语句关于n所占存储空间的函数。

# 线性表
## 线性表的定义
线性表（List）：零个或多个数据元素的有限序列
线性表元素的个数n（n>=0）定义为线性表的长度，当0=0时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。
## 线性表的抽象数据类型
1. 每个元素的类型均为DataType
2. 除第一个元素外每个元素有且只有一个直接前驱元素；除对后一个元素外每个元素有且只有一个直接后继元素
3. 数据元素之间的关系是一对一
## 线性表的顺序存储结构
### 顺序存储定义
有一段地址连续的存储单元一次存储线性表的数据元素
### 顺序存储方式
描述顺序存储结构需要三个属性
1. 存储空间的起始位置
2. 线性表的最大存储容量：MaxSize
3. 线性表的当前长度：length
### 数据长度与线性表长度区别
数组的长度：存放线性亵的存储空间的长度，存储分配后这个量是一般是不变的
线性袤的长度：线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的
在任意时刻，线性表的长度应该小于等于数组的长度
### 地址计算方法
存储器中的每个存储单元都有自己的编号，这个编号称为地址
线性表的第i个元素是要存储在数组下标为i-1的位置
所以对于第i个数据元素a，的存储位置可以由a1推算得：LOC(ai)= LOC(ai) + (i-l)*c 
## 顺序存储结构的插入与删除
### 获得操作
只要i的数值在数组下标范围内，就是把数组第j-l下标的值返回
### 插入操作
插入算法的思路
1. 如果插入位置不合理，抛出异常
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
3. 从最后一个元素开始向前历遍到第i个位置，分别将他们都向后移动一个位置
4. 将要插入元素填入位置i处
5. 表长+1
### 删除操作
删除算法的思路
1. 如果删除位置不合理，抛出异常
2. 取出删除元素
3. 从删除元素位置开始历遍到最后一个元素位置，分别将他们都向前移动一个位置
4. 表长-1
线性表的顺序存储结构在存、读数据时，时间复杂度为O(1)
而插入或删除时，时间复杂度为O(n)
### 线性表顺序存储结构的优缺点
优点：
1. 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
2. 可以快速地存取表中任一位置的元素
缺点：
1. 插入或删除操作需要移动大量元素
2. 当线性表长度变化较大时，难以确定存储空间的容量
3. 造成存储空间的“碎片”
## 线性表的链式存储结构
### 线性表链式存储结构定义
1. 为了表示每个数据元素al与其直接后继数据元素al+1之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)
2. 特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
3. 数据域：存储元素信息的域
4. 指针域：存储后继位置的域
5. 指针（链）：指针域中存储的信息
6. 结点（Node）：元素信息和后继位置两部分信息组成数据元素ai的存储映像
7. 线性表的链式存储结构：：n个结点(al的存储映像)链结成一个链表
8. 单链表：每个结点中只包含一个指针域的链表
9. 头指针：链表中第一个结点的存储位置
10. 头结点：：单链表的第一个结点前附设的一个结点，可以不存储任何信息，也可以存储线性表的长度等附加信息
### 头指针与头结点的异同
头指针：
1. 值链表指向第一个结点的指针，若链表有头结点则是指向头结点的指针
2. 头指针具有标识作用，所以常用头指针冠以链表的名字
3. 无论链表是否为空，头指针均不为空
4. 头指针是链表的必要元素
头结点：
1. 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)
2. 有了头结点，对在第一元素结点前插入结点和删除第一结点操作和其他结点的操作就统一了
3. 头结点不是链表的必要元素
## 单链表的读取
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，返回结点p的数据
## 单链表的插入与删除
### 单链表的插入
**更改后继点地址语句的顺序不能修改**
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，在系统中生成一个空结点s
5. 将数据元素e赋值给s->data
6. 单链表的插入标准语句：s->next=p->next;p->=s
7. 返回成功
### 单链表的删除
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，将与删除的结点p->next赋值给q
5. 单链表的删除标准语句p->next = q->next
6. 将q结点中的数据赋值给e，作为返回
7. 释放q结点
8. 返回成功
对于插入或删除数据越频繁的操作，单链衰的效率优势就越是明显。
## 单链表的整表创建
1. 声明一结点p和计数器变量i
2. 初始化一空链表L
3. 让L的头结点的指针指向BULL，即建立一个带头结点的单链表
4. 循环：
    （插队法）
    * 生成一新节点赋值给p
    * 随机生成一数字赋值给p的数据域
    * 将p插入到头结点与前一新节点之间 
    （尾插法）
## 单链表的整表删除
1. 声明一结点p和q
2. 将第一个结点赋值给p
3. 循环：
    * 将下一结点赋值给q
    * 释放p
    * 将q赋值给p
## 单链表结构与顺序存储结构优缺点
### 存储分配方式：
1. 顺序存储结构用一段连续的存储单元一次存储线性表的数据元素
2. 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
### 时间性能
1. 查找
    * 顺序存储结构O（1）
    * 单链表O（n）
2. 插入与删除
    * 顺序存储结构平均需要移动表长的一半元素，时间为O（n）
    * 单链表在寻找出某位置的指针后，插入和删除时间均为O（1）
### 空间性能
1. 顺序存储结构需要预分配存储空间。分大了浪费；分小了易发生上溢
2. 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制
优缺点：
1. 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。
若需要频繁插入和删除时，宜采用单链表结构
2. 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构；
而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多
## 静态链表
### 静态链表概念
用数组描述的链表叫做静态链表
备用链表：未被使用的数组元素
数组第一个元素，即下标为0的元素的cur就存放备用链袤的第一个结点的下标
数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点
数组的cur与存储顺序相反
### 静态链表插入操作
不移动元素，通过修改cur插入数据
### 静态链表的删除操作
直接修改数组最后一个元素的cur
### 静态链表的优缺点
#### 优点
在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插人和删除操作需要移动大量元素的缺点
#### 缺点
1. 没有解决连续存储分配带来的表长难以确定的问题
2. 失去了顺序存储结构随机存取的特性
## 循环链表
循环链表：将单链表中终端结点的指针端自空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链
## 双向链表
双向链表：在单链袤的每个结点中，再设置一个指向其前驱结点的指针域

git reset --mixed 26919ee72f67cbbeeb039131d16d74e4d2dfedac
commit 26919ee72f67cbbeeb039131d16d74e4d2dfedac (origin/master)
Author: wsy425 <1565330830@qq.com>
Date:   Fri Sep 18 21:05:39 2020 +0800

    2020.9.18