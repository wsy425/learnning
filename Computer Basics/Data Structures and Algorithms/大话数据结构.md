# 数据结构绪论
## 基本概念和数据
### 数据
描述客观事物的符号；计算机可操作对象，能被计算机识别并输入给计算机处理
### 数据元素
组成数据的、有一定意义的基本单位，在计算机中作为整体处理
### 数据项
数据项是数据不可分割的最小单位
一个数据元素可以由若干个数据项组成
### 数据对象
性质相同的数据元素的集合，是数据的子集
### 数据结构
相互之间存在一种或多种特定关系的数据元素集合
## 逻辑结构与物理结构
数据结构分为逻辑结构和物理结构
### 逻辑结构（面向问题）
数据对象中数据元素之间的相互关系
1. 集合结构：数据元素处理同属于一个集合外，之间没有其他关系
2. 线性结构：数据元素之间是一对一关系
3. 树形结构：数据元素之间存在一种一对多的层次关系
4. 图形结构：数据元素是多对多的关系
### 物理结构（面向计算机）
数据的逻辑结构在计算机中的存储形式
1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致
2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据存储关系不能反映逻辑关系，需要用执政存放数据元素地址
## 抽象数据类型
### 数据类型
数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称
### 抽象数据类型
抽象数据类型（ADT）：是指一个数学模型及定义在该模型上的一组操作


# 算法（Algorithm）
与MOOC绪论联系
## 算法定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
## 算法的特性
### 输入输出
算法具有零个或多个输入，至少有一个输出
### 有穷性
算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成
### 确定性
算法的每一步骤都具有确定的含义
### 可行性
算法每一步都必须是可行的，每一步都能通过执行有限次数完成
## 算法设计要求
### 正确性
算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
分成四个层次：
1. 没有语法错误
2. 对于合法的输入数据能够产生满足要求的输出结
3. 对于非法的输入数据能够得出满足规格说明的结果。
4. 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
### 可读性
算法设计的另一目的是为了便于阅读、理解和交流
### 健壮性
当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
### 时间效率高、存储量低
设计算法应该尽量满足时间效率高和存储量低的需求
## 算法效率的度量方法
### 事后统计方法
主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
缺陷多
### 事前分析估计方法
计算机程序编制前，依据统计方法对算法进行估算
在分析程序的运行时间时，最重要的是把程序看成是强立于程序设计语言的算法或一系列步骤
## 函数的渐进增长
函数的渐近增长:给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n> N, f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快子g（n）
通过函数的渐进增长得出结论：
判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数
## 算法时间复杂度（）
### 算法时间复杂度定义
T（n）=O（f（n）），大O记法
O（1）：常数阶
O（n）：线性阶
O（n^2）：平方阶
### 大O阶方法
1. 忽略常数项
2. 忽略低阶项
3. 忽略常系数
### 常见时间复杂度
![QQ截图20200918205835.jpg](https://i.loli.net/2020/09/18/bPImFSq29ltLzWh.jpg)
### 最坏情况与平均情况
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时闯是所有情况中最有意义的，因为它是期望的运行时间。
## 算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(o)= O(f(o))，其中，0为问题的规模，f(n)为语句关于n所占存储空间的函数。

# 线性表
## 线性表的定义
线性表（List）：零个或多个数据元素的有限序列
线性表元素的个数n（n>=0）定义为线性表的长度，当0=0时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。
## 线性表的抽象数据类型
1. 每个元素的类型均为DataType
2. 除第一个元素外每个元素有且只有一个直接前驱元素；除对后一个元素外每个元素有且只有一个直接后继元素
3. 数据元素之间的关系是一对一
## 线性表的顺序存储结构
### 顺序存储定义
有一段地址连续的存储单元一次存储线性表的数据元素
### 顺序存储方式
描述顺序存储结构需要三个属性
1. 存储空间的起始位置
2. 线性表的最大存储容量：MaxSize
3. 线性表的当前长度：length
### 数据长度与线性表长度区别
数组的长度：存放线性亵的存储空间的长度，存储分配后这个量是一般是不变的
线性袤的长度：线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的
在任意时刻，线性表的长度应该小于等于数组的长度
### 地址计算方法
存储器中的每个存储单元都有自己的编号，这个编号称为地址
线性表的第i个元素是要存储在数组下标为i-1的位置
所以对于第i个数据元素a，的存储位置可以由a1推算得：LOC(ai)= LOC(ai) + (i-l)*c 
## 顺序存储结构的插入与删除
### 获得操作
只要i的数值在数组下标范围内，就是把数组第j-l下标的值返回
### 插入操作
插入算法的思路
1. 如果插入位置不合理，抛出异常
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
3. 从最后一个元素开始向前历遍到第i个位置，分别将他们都向后移动一个位置
4. 将要插入元素填入位置i处
5. 表长+1
### 删除操作
删除算法的思路
1. 如果删除位置不合理，抛出异常
2. 取出删除元素
3. 从删除元素位置开始历遍到最后一个元素位置，分别将他们都向前移动一个位置
4. 表长-1
线性表的顺序存储结构在存、读数据时，时间复杂度为O(1)
而插入或删除时，时间复杂度为O(n)
### 线性表顺序存储结构的优缺点
优点：
1. 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
2. 可以快速地存取表中任一位置的元素
缺点：
1. 插入或删除操作需要移动大量元素
2. 当线性表长度变化较大时，难以确定存储空间的容量
3. 造成存储空间的“碎片”
## 线性表的链式存储结构
### 线性表链式存储结构定义
1. 为了表示每个数据元素al与其直接后继数据元素al+1之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)
2. 特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
3. 数据域：存储元素信息的域
4. 指针域：存储后继位置的域
5. 指针（链）：指针域中存储的信息
6. 结点（Node）：元素信息和后继位置两部分信息组成数据元素ai的存储映像
7. 线性表的链式存储结构：：n个结点(al的存储映像)链结成一个链表
8. 单链表：每个结点中只包含一个指针域的链表
9. 头指针：链表中第一个结点的存储位置
10. 头结点：：单链表的第一个结点前附设的一个结点，可以不存储任何信息，也可以存储线性表的长度等附加信息
### 头指针与头结点的异同
头指针：
1. 值链表指向第一个结点的指针，若链表有头结点则是指向头结点的指针
2. 头指针具有标识作用，所以常用头指针冠以链表的名字
3. 无论链表是否为空，头指针均不为空
4. 头指针是链表的必要元素
头结点：
1. 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)
2. 有了头结点，对在第一元素结点前插入结点和删除第一结点操作和其他结点的操作就统一了
3. 头结点不是链表的必要元素
## 单链表的读取
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，返回结点p的数据
## 单链表的插入与删除
### 单链表的插入
**更改后继点地址语句的顺序不能修改**
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，在系统中生成一个空结点s
5. 将数据元素e赋值给s->data
6. 单链表的插入标准语句：s->next=p->next;p->=s
7. 返回成功
### 单链表的删除
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，将与删除的结点p->next赋值给q
5. 单链表的删除标准语句p->next = q->next
6. 将q结点中的数据赋值给e，作为返回
7. 释放q结点
8. 返回成功
对于插入或删除数据越频繁的操作，单链衰的效率优势就越是明显。
## 单链表的整表创建
1. 声明一结点p和计数器变量i
2. 初始化一空链表L
3. 让L的头结点的指针指向BULL，即建立一个带头结点的单链表
4. 循环：
    （插队法）
    * 生成一新节点赋值给p
    * 随机生成一数字赋值给p的数据域
    * 将p插入到头结点与前一新节点之间 
    （尾插法）
## 单链表的整表删除
1. 声明一结点p和q
2. 将第一个结点赋值给p
3. 循环：
    * 将下一结点赋值给q
    * 释放p
    * 将q赋值给p
## 单链表结构与顺序存储结构优缺点
### 存储分配方式：
1. 顺序存储结构用一段连续的存储单元一次存储线性表的数据元素
2. 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
### 时间性能
1. 查找
    * 顺序存储结构O（1）
    * 单链表O（n）
2. 插入与删除
    * 顺序存储结构平均需要移动表长的一半元素，时间为O（n）
    * 单链表在寻找出某位置的指针后，插入和删除时间均为O（1）
### 空间性能
1. 顺序存储结构需要预分配存储空间。分大了浪费；分小了易发生上溢
2. 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制
优缺点：
1. 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。
若需要频繁插入和删除时，宜采用单链表结构
2. 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构；
而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多
## 静态链表
### 静态链表概念
用数组描述的链表叫做静态链表
备用链表：未被使用的数组元素
数组第一个元素，即下标为0的元素的cur就存放备用链袤的第一个结点的下标
数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点
数组的cur与存储顺序相反
### 静态链表插入操作
不移动元素，通过修改cur插入数据
### 静态链表的删除操作
直接修改数组最后一个元素的cur
### 静态链表的优缺点
#### 优点
在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插人和删除操作需要移动大量元素的缺点
#### 缺点
1. 没有解决连续存储分配带来的表长难以确定的问题
2. 失去了顺序存储结构随机存取的特性
## 循环链表
循环链表：将单链表中终端结点的指针端自空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链
## 双向链表
双向链表：在单链袤的每个结点中，再设置一个指向其前驱结点的指针域

# 栈与队列
## 栈的定义
1. 栈（stack）：限定仅在表尾进行捕入和删除操作的线性表
2. 栈顶（top）:允许插入和删除的一端
3. 栈底（bottom）：不允许插入和删除的一端
4. 空栈：不含任何数据元素的栈
5. 栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构
6. 进栈：栈的插入操作，也称压栈、入栈
7. 出栈：栈的删除操作，也称弹栈
8. 出栈的次序由进栈的次序决定，有许多变化
## 栈的抽象数据类型
1. 插入push
2. 删除pop
## 栈的顺序存储结构
### 栈的顺序存储结构
1. 以栈底作为0
2. top变量表示栈顶元素在数组中的位置
3. StackSize为栈长，一定大于top（top从0开始计数，所以满栈也小1）
4. 空栈：top=-1
### 顺序存储结构进栈、出栈操作
```C++
#进栈
S->top++;
S->data[S->top]=e; 
#出栈
e=S->data (S->top] ; 
S ->top--
```
两者都没有设计到循环语句，时间复杂度为O（1）
## 两栈共享空间
1. 让一个栈的栈底为数组的始端，即下标为0处，另一个栈弟为栈的末端，即下标为数组长度n-l处，两个栈向中间延展
2. 空栈定义：对于栈1，top1 = -1；对于栈2，top2 = n
3. 栈满定义：top1 + 1 == top2
4. 一般用于两个栈的空间需求有相反关系时，且数据类型相同
## 栈的链式存储结构及实现
### 栈的链式存储结构
1. 栈的链式结构，简称链栈
2. 链栈一般吧栈顶放在单链表的头部，且不需要头部结点
3. 对于链栈基本不存在栈满，空栈的定义为top = NULL
### 链式存储结构进栈、出栈操作
```C++
#进栈
s->data=e;
s->next=S->top;
S->top=s;
S->count++; 
#出栈
*e=S->top->data;
p=s->top;
S->top=s->top->next; /* 从栈顶开始取数据 */
free (p)；
S->count--; 
```
## 栈的作用
栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。
## 栈的应用——递归
### 斐波那契数列实现
``` python
# 递归法
def fbi1(n):
    if n<2:
        return 1
    else:
        return fbi1(n-1) + fbi1(n-2)
# 动态规划
f = 0
g = 1
while (0 < n):
    g = g + f
    f = g - f
    return g
```
### 递归定义
递归函数：把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数
每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出
## 栈的应用——四则运算表达式
### 后缀表示法
所有的符号都是在要运算数字的后面出现
### 后缀表达式计算结果
从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进钱，一直到最终获得结果。
### 中缀表达式转后缀表达式
从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
## 队列的定义
1. 只允许在一端进行插入操作，而在另一端进行删除操作的线性表
2. 队列是一种先进先出（First In First Out）的线性表，简称FIFO
3. 允许插入的一端称为队尾，允许删除的一端称为队头
## 循环队列
### 队列顺序存储的不足
入列元素时间复杂度为O(1)，但出列元素的时间复杂度为O(n)
### 循环队列定义
头尾相接的顺序存储结构
判断队列空满：
1. 设置一个标志变量flag，当front== rear，且flag= 0时为队列空，当front== rear，且flag= 1时为队列满
2. 当队列空时front =rear，；当队列满时修改条件保留一个元素，条件为(rear + 1) % QueueSize == front（QueueSize为队列最大尺寸）
## 队列的链式存储结构及实现
队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列
### 入队操作
链表尾部插入结点
### 出队操作
头结点的后继结点出队，把头结点的后继改成它后面的结点
若链表除头结点外只剩一个元素时，将rear指向头结点
### 与循环队列比较
1. 时间上，基本操作都是O(1)，链队列每次申请和释放结点存在一些时间开销
2. 空间上，循环队列必须有固定长度，有存储元素个数和空间浪费的问题
3. 确定列表长度最大值时使用循环队列；无法预估队列长度时使用链队列

# 串
## 串的定义
1. 串（string）是由零个或多个字符组成的有限序列，又名字符串
2. 串的长度：串中字符的数目n
3. 空串：零个字符的串
4. 空格串：只含空格的串
5. 子串：传中任意个数的连续字符组成的子序列
5. 主串：包含子串的串
6. 子串在主串中的位置就是子串的第一个字符在主串中的位置
## 串的比较
串的比较是通过组成串的字符之间的编码来进行的
必须串的长度以及它们各个对应位置的字符都相等时才算两串相等
1. 前序字符都相等，长串大
2. 第一个不相同字符编码大的串大
## 串的存储结构
### 串的顺序存储结构
用一组地址连续的存储单元来存储串中的字符序列
### 串的链式存储结构
一个结点存放多个字符，最后一个结点若是未被占满，可以用#或者其他非串值字符补全
串的链式存储结构处理在连接串与串操作时有一定方便外，总得来说不如顺序存储灵活，性能也不如顺序存储结构好
## 朴素的模式匹配算法
1. 模式匹配：子串的定位操作
2. 算法：对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止
```python
def Pattern_matching(str_1 , str_2):
    i = p = 0
    while i<len(str_1):
        i = p
        j = 0
        while j<len(str_2):
            if str_1[i] == str_2[j]:
                i += 1
                j += 1
            else:
                break
        if j == len(str_2):
            print(p)
            break
        p += 1
```
时间复杂度O((n-m+1)*m)
## KMP模式匹配算法
### KMP模式匹配算法原理
i不回溯（不大懂为什么）
### next数组值推导
前后缀n个字符相等k = n + 1
**算法重现**
时间复杂度O(n+m)
### KMP模式匹配算法改进
对next函数改进nextval
a为字符与它next值指向的b位字符相等，则a的nextval就等于b位的nextval值；否则则为自身的next值

# 树
## 树的定义
1. 一对多的数据结构
2. 树(Tree)是n个结点的有限集。n=O时称为空树.在任意一棵非空树中
   * 有旦仅有**一个**特定的称为根(Root)的结点
   * 当n>1时，其余结点可分为m(m>O)个**互不相交**的有限集，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。
3. n>0时根节点是唯一的，不可能村阿紫多个根节点
4. m>0时子树的个数没有限制，但它们一定是互不相交的
### 结点分类
1. Degree：结点的度，结点拥有的子树数
2. Leaf：叶节点、终端结点，度为0的结点
3. 分支节点：非终端结点
4. 内部结点： 除去根节点的分支节点
5. 树的度：树内各节点度的最大值
### 结点间关系
1. 孩子：结点的子树的根称为结点的孩子
2. 双亲：结点为结点孩子的双亲
3. 兄弟：同一双亲的孩子之间互称兄弟
4. 祖先：结点的祖先是从根到该节点所经分支上的所有结点
5. 子孙：以某结点为根的子树中的任一结点都是该节点的子孙
### 树的其他相关概念
1. Level：层次，从根开始定义起，根为第一层，根的孩子为第二层
2. Depth：深度、高度，树中结点的最大层次
3. 有序树、无序树：若树中结点的各子树从左至右有次序，不能互换则为有序树；否则为无序树
4. Forest：森林，m棵互不相交的树的集合
## 树的存储结构
### 双亲表示法
每个结点中附设一个指示器指示双亲结点到链表中的位置
不容易找结点的孩子
有时附设长子域或右兄弟域
### 孩子表示法
每个结点有多个指针域，其中每个指针指向一棵子树的根结点，多重链表示法
把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性衰，采用顺序存储结构，存放进一个一维数组中
### 孩子兄弟表示法
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟
## 二叉树的定义
二叉树(Binary Tree)是n个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的**左子树**和**右子树**的二叉树组成。
### 二叉树特点
1. 每个结点最多有两棵子树，没有子树或者由一棵子树都是可以的
2. 左子树和右子树是有顺序的，次序不能任意颠倒
3. 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树
### 特殊二叉树
1. 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树
2. 满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树
    * 叶子只能出现在最下一层。出现在其他层就不可能达成平衡
    * 非叶子结点的度一定是2
    * 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。
3. 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树
    * 叶子结点只能出现在最下两层
    * 最下层的叶子一定集中在左部连续位置
    * 倒数二层，若有叶子结点，一定都在右部连续位
    * 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情
    * 同样结点数的二叉树，完全二叉树的深度最小
## 二叉树的性质
1. 在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
2. 深度为k的二叉树至多有2^k-1个结点(k>=l)
3.  对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2,则n0=n2+1
4. 具有n个结点的完全二叉树的深度为[ logn ]+ 1 ([ x ]表示不大于直的最大整数)(log以2为底)
5. 如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i：
    * 如果i=1，则结点i是二叉树的棍，无双亲;如果i>1，则其双亲是结点[ i/2 ]
    * 如果2i>n，则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i
    * 如果2i+1>n，则结点i无右孩子;否则其右孩子是结点2i+1
## 二叉树的存储结构
### 二叉树的顺序存储结构
按顺序存储，将不存在的结点设置为^即可
### 二叉链表
设计一个数据域和两个指针域
## 历遍二叉树
二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种**次序**依次访问二叉树中所有结点.使得每个结点被**访问**一次且仅被访问一次
### 前序历遍
规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树
```c++
void InOrderTraverse (BiTree T) 
{
    if (T==NllLL)
        return;
    printf ("%c"，T→data);
    InOrderTraverse (T->lchild);
    lnOrderTraverse (T->rchild);
}
```
### 中序历遍
规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树
```c++
void InOrderTraverse (BiTree T) 
{
    if (T==NllLL)
        return;
    InOrderTraverse (T->lchild) ;
    printf ("%c"，T→data);
    lnOrderTraverse (T->rchild) ;
}
```
### 后序遍历
规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点
```c++
void InOrderTraverse (BiTree T) 
{
    if (T==NllLL)
        return;
    InOrderTraverse (T->lchild);
    lnOrderTraverse (T->rchild);
    printf ("%c"，T→data);
}
```
### 层序遍历
规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的颇用才结点逐个访问
### 二叉树遍历性质
1. 己知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树
2. 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树
3. 已知前序和后序遍历，不能确定一棵二叉树
## 二叉树的建立
建立二叉树，也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作
## 线索二叉树
指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)
## 树、森林与二叉树的转换
### 树转换为二叉树
1. 加线：在所有兄弟结点之间加一条连线
2. 去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除色与其他孩子结点之间的连线
3. 层次调整：以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子
### 森林转换为二叉树
1. 把每个树转换为二叉树
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树
### 二叉树转换为树
1. 加线：将该结点与这些右孩子结点用线连接起
2. 去线：删除原二叉树中所有结点与其右孩子结点的连线
3. 层次调整
### 二叉树转换成森林
1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，直到所有右孩子连线都删除为止，得到分离的二叉树
2. 再将每棵分离后的二叉树转换为树即可
### 树与森林的遍历
#### 树的遍历
1. 先访问树的根节点，以次先根遍历根的每棵子树
2. 另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点
#### 森林遍历
1. 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林
2. 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林
## 赫夫曼树及其应用
从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度
树的路径长度就是从树根到每一结点的路径长度之和
赫夫曼树：最优二叉树，带权路径长度WPL最小的二叉树

# 图
## 图的定义
图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为:G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
1. 数据元素：
    图：顶点（Vertex）
    线性表：元素
    树：结点
2. 图结构中不允许没有顶点，不存在空图
3. 数据元素关系：
    图：任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空集
    线性表：相邻的数据元素之间具有线性关系
    树：相邻两层的结点具有层次关系
### 图的相关定义
1. 无向边：若顶点V1iVj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(Vi,Vj)来表示
2. 无向图（Undirected graphs）：图中任意两个顶点之间的边都是无向边
3. 有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也称为弧（Arc），用有序偶< Vi,Vj >来表示
4. 弧尾（Tail）：< Vi,Vj >中Vi
5. 弧头（Head）：< Vi,Vj >中Vj
6. 有向图（Directed graphs）：图中任意两个顶点之间的边都是有向边
7. 简单图：图中不存在顶点到自身的边，且同一条边不重复出现
8. 无向完全图：任意两个顶点之间都存在边的无向图
9. 有向完全图：任意两个顶点之间都存在方向互为相反的两条弧的有向图
10. 稀疏图：边或弧很少的图
11. 稠密图：边或弧很多的图
12. 权（Weight）：与图的边或弧相关的数
13. 网（Network）：带权的图
### 图的顶点与边间的关系
1. 度（Degree）：和该顶点相关联的边的数目