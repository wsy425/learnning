# 数据结构绪论
## 基本概念和数据
### 数据
描述客观事物的符号；计算机可操作对象，能被计算机识别并输入给计算机处理
### 数据元素
组成数据的、有一定意义的基本单位，在计算机中作为整体处理
### 数据项
数据项是数据不可分割的最小单位
一个数据元素可以由若干个数据项组成
### 数据对象
性质相同的数据元素的集合，是数据的子集
### 数据结构
相互之间存在一种或多种特定关系的数据元素集合
## 逻辑结构与物理结构
数据结构分为逻辑结构和物理结构
### 逻辑结构（面向问题）
数据对象中数据元素之间的相互关系
1. 集合结构：数据元素处理同属于一个集合外，之间没有其他关系
2. 线性结构：数据元素之间是一对一关系
3. 树形结构：数据元素之间存在一种一对多的层次关系
4. 图形结构：数据元素是多对多的关系
### 物理结构（面向计算机）
数据的逻辑结构在计算机中的存储形式
1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致
2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据存储关系不能反映逻辑关系，需要用执政存放数据元素地址
## 抽象数据类型
### 数据类型
数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称
### 抽象数据类型
抽象数据类型（ADT）：是指一个数学模型及定义在该模型上的一组操作


# 算法（Algorithm）
与MOOC绪论联系
## 算法定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
## 算法的特性
### 输入输出
算法具有零个或多个输入，至少有一个输出
### 有穷性
算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成
### 确定性
算法的每一步骤都具有确定的含义
### 可行性
算法每一步都必须是可行的，每一步都能通过执行有限次数完成
## 算法设计要求
### 正确性
算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
分成四个层次：
1. 没有语法错误
2. 对于合法的输入数据能够产生满足要求的输出结
3. 对于非法的输入数据能够得出满足规格说明的结果。
4. 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
### 可读性
算法设计的另一目的是为了便于阅读、理解和交流
### 健壮性
当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
### 时间效率高、存储量低
设计算法应该尽量满足时间效率高和存储量低的需求
## 算法效率的度量方法
### 事后统计方法
主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
缺陷多
### 事前分析估计方法
计算机程序编制前，依据统计方法对算法进行估算
在分析程序的运行时间时，最重要的是把程序看成是强立于程序设计语言的算法或一系列步骤
## 函数的渐进增长
函数的渐近增长:给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n> N, f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快子g（n）
通过函数的渐进增长得出结论：
判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数
## 算法时间复杂度（）
### 算法时间复杂度定义
T（n）=O（f（n）），大O记法
O（1）：常数阶
O（n）：线性阶
O（n^2）：平方阶
### 大O阶方法
1. 忽略常数项
2. 忽略低阶项
3. 忽略常系数
### 常见时间复杂度
![QQ截图20200918205835.jpg](https://i.loli.net/2020/09/18/bPImFSq29ltLzWh.jpg)
### 最坏情况与平均情况
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时闯是所有情况中最有意义的，因为它是期望的运行时间。
## 算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(o)= O(f(o))，其中，0为问题的规模，f(n)为语句关于n所占存储空间的函数。

# 线性表
## 线性表的定义
线性表（List）：零个或多个数据元素的有限序列
线性表元素的个数n（n>=0）定义为线性表的长度，当0=0时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。
## 线性表的抽象数据类型
1. 每个元素的类型均为DataType
2. 除第一个元素外每个元素有且只有一个直接前驱元素；除对后一个元素外每个元素有且只有一个直接后继元素
3. 数据元素之间的关系是一对一
## 线性表的顺序存储结构
### 顺序存储定义
有一段地址连续的存储单元一次存储线性表的数据元素
### 顺序存储方式
描述顺序存储结构需要三个属性
1. 存储空间的起始位置
2. 线性表的最大存储容量：MaxSize
3. 线性表的当前长度：length
### 数据长度与线性表长度区别
数组的长度：存放线性亵的存储空间的长度，存储分配后这个量是一般是不变的
线性袤的长度：线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的
在任意时刻，线性表的长度应该小于等于数组的长度
### 地址计算方法
存储器中的每个存储单元都有自己的编号，这个编号称为地址
线性表的第i个元素是要存储在数组下标为i-1的位置
所以对于第i个数据元素a，的存储位置可以由a1推算得：LOC(ai)= LOC(ai) + (i-l)*c 
## 顺序存储结构的插入与删除
### 获得操作
只要i的数值在数组下标范围内，就是把数组第j-l下标的值返回
### 插入操作
插入算法的思路
1. 如果插入位置不合理，抛出异常
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
3. 从最后一个元素开始向前历遍到第i个位置，分别将他们都向后移动一个位置
4. 将要插入元素填入位置i处
5. 表长+1
### 删除操作
删除算法的思路
1. 如果删除位置不合理，抛出异常
2. 取出删除元素
3. 从删除元素位置开始历遍到最后一个元素位置，分别将他们都向前移动一个位置
4. 表长-1
线性表的顺序存储结构在存、读数据时，时间复杂度为O(1)
而插入或删除时，时间复杂度为O(n)
### 线性表顺序存储结构的优缺点
优点：
1. 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
2. 可以快速地存取表中任一位置的元素
缺点：
1. 插入或删除操作需要移动大量元素
2. 当线性表长度变化较大时，难以确定存储空间的容量
3. 造成存储空间的“碎片”
## 线性表的链式存储结构
### 线性表链式存储结构定义
1. 为了表示每个数据元素al与其直接后继数据元素al+1之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)
2. 特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
3. 数据域：存储元素信息的域
4. 指针域：存储后继位置的域
5. 指针（链）：指针域中存储的信息
6. 结点（Node）：元素信息和后继位置两部分信息组成数据元素ai的存储映像
7. 线性表的链式存储结构：：n个结点(al的存储映像)链结成一个链表
8. 单链表：每个结点中只包含一个指针域的链表
9. 头指针：链表中第一个结点的存储位置
10. 头结点：：单链表的第一个结点前附设的一个结点，可以不存储任何信息，也可以存储线性表的长度等附加信息
### 头指针与头结点的异同
头指针：
1. 值链表指向第一个结点的指针，若链表有头结点则是指向头结点的指针
2. 头指针具有标识作用，所以常用头指针冠以链表的名字
3. 无论链表是否为空，头指针均不为空
4. 头指针是链表的必要元素
头结点：
1. 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)
2. 有了头结点，对在第一元素结点前插入结点和删除第一结点操作和其他结点的操作就统一了
3. 头结点不是链表的必要元素
## 单链表的读取
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，返回结点p的数据
## 单链表的插入与删除
### 单链表的插入
**更改后继点地址语句的顺序不能修改**
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，在系统中生成一个空结点s
5. 将数据元素e赋值给s->data
6. 单链表的插入标准语句：s->next=p->next;p->=s
7. 返回成功
### 单链表的删除
1. 声明一个结点p指向链表第一结点，初始化j从1开始
2. 当j< i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，将与删除的结点p->next赋值给q
5. 单链表的删除标准语句p->next = q->next
6. 将q结点中的数据赋值给e，作为返回
7. 释放q结点
8. 返回成功
对于插入或删除数据越频繁的操作，单链衰的效率优势就越是明显。
## 单链表的整表创建
1. 声明一结点p和计数器变量i
2. 初始化一空链表L
3. 让L的头结点的指针指向BULL，即建立一个带头结点的单链表
4. 循环：
    （插队法）
    * 生成一新节点赋值给p
    * 随机生成一数字赋值给p的数据域
    * 将p插入到头结点与前一新节点之间 
    （尾插法）
## 单链表的整表删除
1. 声明一结点p和q
2. 将第一个结点赋值给p
3. 循环：
    * 将下一结点赋值给q
    * 释放p
    * 将q赋值给p
## 单链表结构与顺序存储结构优缺点
### 存储分配方式：
1. 顺序存储结构用一段连续的存储单元一次存储线性表的数据元素
2. 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
### 时间性能
1. 查找
    * 顺序存储结构O（1）
    * 单链表O（n）
2. 插入与删除
    * 顺序存储结构平均需要移动表长的一半元素，时间为O（n）
    * 单链表在寻找出某位置的指针后，插入和删除时间均为O（1）
### 空间性能
1. 顺序存储结构需要预分配存储空间。分大了浪费；分小了易发生上溢
2. 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制
优缺点：
1. 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。
若需要频繁插入和删除时，宜采用单链表结构
2. 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构；
而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多
## 静态链表
### 静态链表概念
用数组描述的链表叫做静态链表
备用链表：未被使用的数组元素
数组第一个元素，即下标为0的元素的cur就存放备用链袤的第一个结点的下标
数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点
数组的cur与存储顺序相反
### 静态链表插入操作
不移动元素，通过修改cur插入数据
### 静态链表的删除操作
直接修改数组最后一个元素的cur
### 静态链表的优缺点
#### 优点
在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插人和删除操作需要移动大量元素的缺点
#### 缺点
1. 没有解决连续存储分配带来的表长难以确定的问题
2. 失去了顺序存储结构随机存取的特性
## 循环链表
循环链表：将单链表中终端结点的指针端自空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链
## 双向链表
双向链表：在单链袤的每个结点中，再设置一个指向其前驱结点的指针域

# 栈与队列
## 栈的定义
1. 栈（stack）：限定仅在表尾进行捕入和删除操作的线性表
2. 栈顶（top）:允许插入和删除的一端
3. 栈底（bottom）：不允许插入和删除的一端
4. 空栈：不含任何数据元素的栈
5. 栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构
6. 进栈：栈的插入操作，也称压栈、入栈
7. 出栈：栈的删除操作，也称弹栈
8. 出栈的次序由进栈的次序决定，有许多变化
## 栈的抽象数据类型
1. 插入push
2. 删除pop
## 栈的顺序存储结构
### 栈的顺序存储结构
1. 以栈底作为0
2. top变量表示栈顶元素在数组中的位置
3. StackSize为栈长，一定大于top（top从0开始计数，所以满栈也小1）
4. 空栈：top=-1
### 顺序存储结构进栈、出栈操作
```C++
#进栈
S->top++;
S->data[S->top]=e; 
#出栈
e=S->data (S->top] ; 
S ->top--
```
两者都没有设计到循环语句，时间复杂度为O（1）
## 两栈共享空间
1. 让一个栈的栈底为数组的始端，即下标为0处，另一个栈弟为栈的末端，即下标为数组长度n-l处，两个栈向中间延展
2. 空栈定义：对于栈1，top1 = -1；对于栈2，top2 = n
3. 栈满定义：top1 + 1 == top2
4. 一般用于两个栈的空间需求有相反关系时，且数据类型相同
## 栈的链式存储结构及实现
### 栈的链式存储结构
1. 栈的链式结构，简称链栈
2. 链栈一般吧栈顶放在单链表的头部，且不需要头部结点
3. 对于链栈基本不存在栈满，空栈的定义为top = NULL
### 链式存储结构进栈、出栈操作
```C++
#进栈
s->data=e;
s->next=S->top;
S->top=s;
S->count++; 
#出栈
*e=S->top->data;
p=s->top;
S->top=s->top->next; /* 从栈顶开始取数据 */
free (p)；
S->count--; 
```
## 栈的作用
栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。
## 栈的应用——递归
### 斐波那契数列实现
``` python
# 递归法
def fbi1(n):
    if n<2:
        return 1
    else:
        return fbi1(n-1) + fbi1(n-2)
# 动态规划
f = 0
g = 1
while (0 < n):
    g = g + f
    f = g - f
    return g
```
### 递归定义
递归函数：把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数
每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出
## 栈的应用——四则运算表达式
### 后缀表示法
所有的符号都是在要运算数字的后面出现
### 后缀表达式计算结果
从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进钱，一直到最终获得结果。
### 中缀表达式转后缀表达式
从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
## 队列的定义
1. 只允许在一端进行插入操作，而在另一端进行删除操作的线性表
2. 队列是一种先进先出（First In First Out）的线性表，简称FIFO
3. 允许插入的一端称为队尾，允许删除的一端称为队头
## 循环队列
### 队列顺序存储的不足
入列元素时间复杂度为O(1)，但出列元素的时间复杂度为O(n)
### 循环队列定义
头尾相接的顺序存储结构
判断队列空满：
1. 设置一个标志变量flag，当front== rear，且flag= 0时为队列空，当front== rear，且flag= 1时为队列满
2. 当队列空时front =rear，；当队列满时修改条件保留一个元素，条件为(rear + 1) % QueueSize == front（QueueSize为队列最大尺寸）
## 队列的链式存储结构及实现
队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列
### 入队操作
链表尾部插入结点
### 出队操作
头结点的后继结点出队，把头结点的后继改成它后面的结点
若链表除头结点外只剩一个元素时，将rear指向头结点
### 与循环队列比较
1. 时间上，基本操作都是O(1)，链队列每次申请和释放结点存在一些时间开销
2. 空间上，循环队列必须有固定长度，有存储元素个数和空间浪费的问题
3. 确定列表长度最大值时使用循环队列；无法预估队列长度时使用链队列

# 串
## 串的定义
1. 串（string）是由零个或多个字符组成的有限序列，又名字符串
2. 串的长度：串中字符的数目n
3. 空串：零个字符的串
4. 空格串：只含空格的串
5. 子串：传中任意个数的连续字符组成的子序列
5. 主串：包含子串的串
6. 子串在主串中的位置就是子串的第一个字符在主串中的位置
## 串的比较
串的比较是通过组成串的字符之间的编码来进行的
必须串的长度以及它们各个对应位置的字符都相等时才算两串相等
1. 前序字符都相等，长串大
2. 第一个不相同字符编码大的串大
## 串的存储结构
### 串的顺序存储结构
用一组地址连续的存储单元来存储串中的字符序列
### 串的链式存储结构
一个结点存放多个字符，最后一个结点若是未被占满，可以用#或者其他非串值字符补全
串的链式存储结构处理在连接串与串操作时有一定方便外，总得来说不如顺序存储灵活，性能也不如顺序存储结构好
## 朴素的模式匹配算法
1. 模式匹配：子串的定位操作
2. 算法：对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止
**算法重现**
时间复杂度O((n-m+1)*m)
## KMP模式匹配算法
### KMP模式匹配算法原理
i不回溯（不大懂为什么）
### next数组值推导
前后缀n个字符相等k = n + 1
**算法重现**
时间复杂度O(n+m)
### KMP模式匹配算法改进
对next函数改进nextval
a为字符与它next值指向的b位字符相等，则a的nextval就等于b位的nextval值；否则则为自身的next值