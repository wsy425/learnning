# 绪论
## 课程目标：计算
## 算法概述
从输入到输出
评价标准：正确性；确定性；可行性
评价工具：图灵机（TM）、RAM
## 渐进分析
### 大O记号
常系数可忽略
低次项可以忽略
大O记号在足够大的时候悲观估计
### 大O记号刻度
1. 常数复杂度
常数包括常数、常数的基本运算、常数的高阶运算
2. 对数复杂度
往往不标明底数、底数对大O会变为常系数，中无所谓
常数次幂无所谓，同上
对数多项式忽略低阶
复杂度无限接近于常数
3. 多项式复杂度
直接看作最高次的复杂度
4. 指数复杂度
难计算的算法
### 其他记号
欧米伽（下界）、斯塔（平均）
### 例子
## 算法分析
两个任务：正确性（不变形 * 单调性） + 复杂性
分析方法：迭代（级数求和）；递归（递归跟踪 + 递推方程）；猜测 + 验证
### 级数
#### 级数类型
算数级数：与末项平方同阶
幂方级数：比幂次高出一阶
几何级数：与末项同阶
收敛级数：O（1）
调和级数：logn
对数级数：nlogn
#### 循环与级数
起泡排序分析
不变形：经k轮扫描交换后，最大的k个元素必然就位
单调性：经k轮扫描交换后，问题规模缩减至n-k
正确性：经至多n趟扫描后，算法必然终止，且能给出正确答案
#### 封底估算
1天 = 10^5 sec
1世纪 = 3 * 10^9 sec
300 年 = 10^10 sec
## 迭代与递归
### 递归跟踪
检查每一个递归实例累积所需时间，其总和即算法执行时间
### 递归方程
相当于解数列
### 算法：简而治之
T（n）=T（n-1）+O（1）
T（1）= O（1）
T（n） - n = T(n-1) - (n-1)
数列求解得T（n）= O（1）+ n = O（n）
### 算法：分而治之
T（n）=2*T（n/2）+O（1）
T（1） = O（1）
T(n) + C1 = 2* (T(n/2) + C1)
T（n）=2* logn *(T(1) +C1) - C1 = n *(C1+C2)=O(n)
## 动态规划
动态规划：通过递归找出算法本质，找到初步解之后，等效转换成迭代
### fib():递归
fib（n） = fib（n-1） + fib（n-2）
#### 递归版
```C++
int fib(n) {return (2>n) ? n : fib(n-1) + fib(n-2)}
```
复杂度T（n）=T（n-1）+T（n-2）+1；T（0）=T（1）=1
令S(n)=[ T(n)+1 ] /2
S(0) = 1 = fib(1); S(1) = 1 = fib(2)
S(n) = S(n-1) +S(n-2) = fib(n+1)
T(n) = 2 * S(n) -1 = 2 *fib(n+1)-1 = O(fib(n+1)) = O(2^n)
封底估算：Φ^36 = 2^25 ; Φ^5 = 10
递归版抵消的根源在于个递归实例均被大量重复地调用
#### 迭代版本
1. 记忆（memoization）
将已计算过的实例结果制表备查
2. 动态规划
颠倒计算方向：由自顶而下递归为自底而上迭代
```C++
f = 0;g = 1;
while (0< n--){
    g = g + f;
    f = g - f;
}
return g;
```
复杂度T（n） = O（n），而且仅需O（1）空间
### LCS：最长公共子序列
#### 递归版本
```python
def LCS(X,Y):
    if not X or not Y:
        return 0, ''
    if X[-1] == Y[-1]:
        length,s = LCS(X[:-1] , Y[:-1])
        return length + 1,s + X[-1]
    else:
        length1,s1 = LCS(X[:-1] , Y)
        length2,s2 = LCS(X , Y[:-1])
        if length1 >= length2:
            return length1 , s1
        else:
            return length2 , s2
```
单调性：没经过一次比对，原问题规模必可减小
#### 动态规划的迭代版本
```python
def LCS2(X,Y):
    arr = np.zeros((len(X)+1, len(Y)+1))
    i = 0;j = 0
    s = ""
    if not X or not Y:
        return 0, ''
    else:
        while i in range(len(X)):
            while j in range(len(Y)):
                if X[i] == Y[j]:
                    arr[i+1,j+1] = arr[i,j] + 1
                    s += X[i]
                else :
                    arr[i+1,j+1] = max(arr[i,j+1] , arr[i+1,j])
                j += 1
            j = 0;i += 1
        return arr[-1,-1] , s 
```